#
# patterns using structs instead of classes.
# requires with-optkeys, arithmetic-test, list-set, tb:rani tb:ranf
# 

#Cycle 	generates its elements in a continuous loop
#Line	generates its elements sequentially and sticks on last element
#Heap	generates random permutations of its elements
#Palindrome	generates its elements forwards and backwards
#Rotation	generates systematic permutations of its elements
#Weighting	generates elements from a weighted random distribution
#Markov	generates nth order Markov chains of its elements
#Graph	generates elements from a directed graph
#Repeater	repeats data generated by a pattern

from scipy import interpolate ,random
import numpy as np
import random as pyrand

CONSTANT_DATA =  0x1 #; avoid hair when possible
DEFAULT_PERIOD =  0x2 #; no period specified
CONSTANT_WEIGHTS = 0x4 #; avoid random index recalc
COUNT_PERIODS  =    0x8 #; period counts subperiods
COUNT_VALUES =    0x16 #; period counts values
DEPTH_FIRST =    0x32  #; pattern moves on eop
BREADTH_FIRST =   0x64  #; pattern moves each time

NAD = 'nad' # ; "not a datum" marker
EOP = 'eop' # "end of period" marker
EOD = 'eod' # "end of data" marker

# the period struct holds information for period calculation.  count
# is number of reads remaining in current period. when count=0 the
# period is reinitialized. length is maximum count of the period,
# either a number or #t if dynamic length. if stream is not #f a new
# length will be read from it each time the period is initialized.
# omit is the number of times this stream is skipped in its parent's
# pattern, if dynamic. Reps keeps track of the number of
# periods. Max is the max number of periods allowed, after which the
# pattern always returns +eod+

def random(*args):
    if (len(args) == 0):
        return np.random.rand()
    else: 
        return between(0, args[0])

class Period(object):
    def __init__(self):
        self.count = 0
        self.length = 0
        self.stream = 0
        self.default = 0
        self.omit = 0
        self.reps = 0

class Pattern(object):
    def __init__(self, dataList = None):
        self.flags = 0
        self.index = 0
        self.dataList = dataList
        self.length = len(dataList)
        #self.datum = 0
        self.period = Period()
        self.value = self.dataList[self.index];
        self.state = 0

       
class Palin(Pattern):
    def __init__(self):
        self.pos = 0
        self.length = 0
        sefl.inc = 0
        self.mode = 0
        self.elide = 0

class RandomItem:
    def __init__(self):
        self.datum = 0
        self.index = 0
        sefl.min = 0
        self.max = 0
        self.count = 0
        self.id = 0
        self.minmax = 0
        
class GraphNode:
    def __init__(self):
        self.datum = 0
        self.to = 0
        sefl.id = 0

#Cycle 	generates its elements in a continuous loop
class Cycle(Pattern):
    def __init__(self, dataList = None):
        Pattern.__init__(self, dataList)
        
    def Next(self):
        ' will retrn the next item in our data list'
        outValue = self.value;
        self.index = (self.index+1)% self.length
        self.value = self.dataList[self.index];
        return outValue
    
    
#Heap	generates random permutations of its elements
class Heap(Pattern):
    def __init__(self, dataList = None):
        Pattern.__init__(self, dataList)
        #super(Pattern,self).__init__()
        self.generateHeap()
        
    def generateHeap(self):
        pyrand.shuffle(self.dataList)
        self.value = self.dataList[self.index];        
    
    def Next(self):
        outValue = self.value
        self.index = (self.index+1)%self.length
        self.value = self.dataList[self.index]
        
        # if we wrap around generate new heap
        if(self.index == 0):
            self.generateHeap()
        
        return outValue   
    
#Line	generates its elements sequentially and sticks on last element
class Line(Pattern):
    def __init__(self, dataList = None):
        self = Pattern.__init__(self, dataList)


#Palindrome	generates its elements forwards and backwards
class Palindrome(Pattern):
    def __init__(self):
        pass

#Rotation	generates systematic permutations of its elements
class Rotation(Pattern):
    def __init__(self):
        pass

#Weighting	generates elements from a weighted random distribution
class Weighting(Pattern):
    def __init__(self):
        pass

#Markov	generates nth order Markov chains of its elements
class Markov(Pattern):
    def __init__(self):
        pass

#Graph	generates elements from a directed graph
class Graph(Pattern):
    def __init__(self):
        pass

#Repeater	repeats data generated by a pattern
class Repeater(Pattern):
    def __init__(self):
        pass



#////////////////////////////////////////////////////////////////////////////////////////////////
if __name__ == '__main__':
    
    print 'Testing Cycle Pattern:'
    
    cyPatttern = Cycle(['a','b','c','d'])
    print 'List: {0}'.format(cyPatttern.dataList)
    print '{0} {1} {2} {3}'.format(cyPatttern.Next(), cyPatttern.Next(), cyPatttern.Next(), cyPatttern.Next())
    print '{0} {1} {2} {3}'.format(cyPatttern.Next(), cyPatttern.Next(), cyPatttern.Next(), cyPatttern.Next())
        
    print 'Testing Heap Pattern:'
    heapPattern = Heap(['a','b','c','d'])
    print 'List: {0}'.format(heapPattern.dataList)
    print '{0} {1} {2} {3}'.format(heapPattern.Next(), heapPattern.Next(), heapPattern.Next(), heapPattern.Next())
    print 'List: {0}'.format(heapPattern.dataList)
    print '{0} {1} {2} {3}'.format(heapPattern.Next(), heapPattern.Next(), heapPattern.Next(), heapPattern.Next())
